# REDIS

￼


## 数据结构

**string**  
底层结构 SDS（Simple Dynamic String ）

`struct sdshdr{
     //记录buf数组中已使用字节的数量
     //等于 SDS 保存字符串的长度
     int len;
     //记录 buf 数组中未使用字节的数量
     int free;
     //字节数组，用于保存字符串
     char buf[];
}`

用处：缓存，计数器，session

**Hash**  
底层结构 哈希表
解决哈希冲突：链地址法

**List**  
底层结构 双向链表
用处：粉丝列表，文章列表，lrange分页，消息队列

**set**  
底层结构 intset
`typedef struct intset{
     //编码方式
     uint32_t encoding;
     //集合包含的元素数量
     uint32_t length;
     //保存元素的数组
     int8_t contents[];
}intset;`
用处：自动去重，交集、并集、差集，

**zset**  
底层结构 跳跃表/压缩列表
跳跃表：
多层链表
最底层的链表包含了所有的元素
链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点
压缩列表
压缩列表并不是对数据利用某种算法进行压缩，而是将数据按照一定规则编码在一块连续的内存区域，目的是节省内存
用处：排行榜

**Bitmap**  
用处：布隆过滤器

**HyperLogLog**：
用处：uv统计

## 持久化

RDB：fork一个子进程去写文件，比较适合做灾备，未来得及备份数据丢失，备份时短期服务不可用  
AOF：支持每秒同步，每次修改同步，运行效率慢于RDB

## 缓存问题

1.雪崩问题
避免缓存在同一时间失效
多级缓存
缓存失效更新加锁，比如go的singleflight算法

2.击穿问题
比如对一个不存在的key进行攻击
布隆过滤器
存储空数据
对参数校验
缓存永不过期
加锁更新缓存

3.数据不一致问题
确保库数据更新正确
重试就行了啊

## 过期策略

**设置方式**  
expire key seconds：设置 key 在 n 秒后过期；
pexpire key milliseconds：设置 key 在 n 毫秒后过期；
expireat key timestamp：设置 key 在某个时间戳（精确到秒）之后过期；
pexpireat key millisecondsTimestamp：设置 key 在某个时间戳（精确到毫秒）之后过期；

**内存淘汰**  
noeviction:返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令（大部分的写入指令，但DEL和几个例外）
allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
allkeys-random: 回收随机的键使得新添加的数据有空间存放。
volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。
如果没有键满足回收的前提条件的话，策略volatile-lru, volatile-random以及volatile-ttl就和noeviction 差不多了。


定时删除：在设置键的过期时间的同时，创建一个定时任务，当键达到过期时间时，立即执行对键的删除操作  
惰性删除：放任键过期不管，但在每次从键空间获取键时，都检查取得的键是否过期，如果过期的话，就删除该键，如果没有过期，就返回该键  
定期删除：每隔一点时间，程序就对数据库进行一次检查，删除里面的过期键，至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。


**集群**

主从  
raft  
复制原理，RDB给到slave  

**哨兵Sentinel**  
在主从的基础上
监控
通知
自动故障转移
原理：当一个master宕机时，会选出一个新的master，修改vip，指向新的master
缺陷：主从切换过程中会丢数据
master压力没有缓解，不能水平扩容

**proxy**

redis cluster
没有中心，官方支持，自动切换，水平扩容
缺陷：批量操作不行

微博的是cacheService L1 main HA
https://mp.weixin.qq.com/s/8H-Hd169s5Hlwn5F2ec25A

##基础问题

1.redis 和 memcached 的区别
与 MC 不同的是，Redis 采用单线程模式处理请求。
这样做的原因有 2 个：一个是因为采用了非阻塞的异步事件处理机制；
另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。
Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。
相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等。
Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。

2.MC弱点
key 不能超过 250 个字节；
value 不能超过 1M 字节；
key 的最大失效时间是 30 天；
只支持 K-V 结构，不提供持久化和主从同步功能。

3.Redis是单线程的，但Redis为什么这么快？
1、完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；
2、数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；
3、采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；
4、使用多路I/O复用模型，非阻塞IO；这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程
5、使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；

4.Redis中海量数据的正确操作方式
利用SCAN系列命令（SCAN、SSCAN、HSCAN、ZSCAN）完成数据迭代。


—————分割线———


单线程，非阻塞（i/o）多路复用
多路指的是网络连接，复用指的是线程
多路复用：select poll epoll，就是一个链接来了，记下，然后哪个socket准备好了再返回
io的读写是异步非阻塞的，调用连接的时候是同步的，同样用于nginx
指令是阻塞的 执行一个耗时的指令会带来灾难性的后果 例如keys *

redis集群问题
主从存在的问题 master写入高

哨兵Sentinel
在主从的基础上
监控
通知
自动故障转移
原理：当一个master宕机时，会选出一个新的master，修改vip，指向新的master
缺陷：主从切换过程中会丢数据
master压力没有缓解，不能水平扩容

proxy

redis cluster
没有中心，官方支持，自动切换，水平扩容
缺陷：批量操作不行

微博的是cacheService L1 main HA
https://mp.weixin.qq.com/s/8H-Hd169s5Hlwn5F2ec25A

缓存穿透的问题
1.布隆过滤器
2.存储空数据
3.上线前缓存预热

删除策略
定时删除
某个key到达过期时间立即删除

定期删除
定期扫

惰性删除
访问的时候再删除

string
可以是字符串 数字 二进制（图片，音频，视频）最大512m
m*指令 （mget mset）减少网络指令请求时间提高效率
每个中文三字节
List
双向链表
Set
无序
redis-pipeline 大规模更新数据
RDB持久化
数据 存到硬盘
AOF持久化
命令存到硬盘，类似binlog

php结合redis做分布式锁 setnx
https://www.jianshu.com/p/238d1ecc5362