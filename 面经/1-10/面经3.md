# 操作系统
1.操作系统的线程与进程的区别，线程的几种状态。  

> 根本区别/内存分配/开销/包含  
> 状态：新建态/就绪态/运行态/阻塞态/终止态

2.线程间通信的方式与进程间通信的方式。实际应用中哪些用到了线程通信和进程通信。 
 

> 线程：  
> 全局变量/消息队列/事件类  
https://www.jianshu.com/p/9218692cb209


> 进程：  
管道pipe：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。  
命名管道FIFO：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。  
消息队列MessageQueue：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。  
共享存储SharedMemory：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。  
信号量Semaphore：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。  
套接字Socket：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。  
信号 ( signal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。  

> 实际应用：  
socket 并发


3.操作系统的僵尸进程和孤儿进程的区别。  

> 僵尸进程
一个进程在调用exit命令结束自己的生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit，它的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁）。

> 孤儿进程  
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
 
4.操作系统的虚拟内存，分段分页，缺页调度的流程。  

> 页式调度  
段式调度  
段页式调度  
link：https://blog.csdn.net/Bob__yuan/article/details/102584606


> **缺页**  
操作系统根据需要读取虚拟地址表，如果读到虚拟地址表中记录的地址被标为“未驻入”，表示这部分地址记录的程序代码未被加载到内存，需要从磁盘读入，则这种情况就表示"缺页"。这个时候，操作系统触发一个“缺页”的硬件陷井，系统从磁盘换入这部分未“驻留”的代码。  
**缺页调度**  
FIFO先进先出和LRU最近最久未使用算法。（？）

5.操作系统的死锁的四个必要条件。且每个条件的含义。  


> 1. 互斥条件：一个资源每次只能被一个进程使用。
>2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
>3. 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
>4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。


6.进程的调度算法。  
> 批处理/交互式/实时

7.磁盘的寻道算法。  


> 先来先服务(FCFS):
　　这是一种简单的磁盘调度算法。它根据进程请求访问磁盘的先后次序进行调度。此算法的优点是公平、简单，且每个进程的请求都能依次得到处理，不会出现某一进程的请求长期得不到满足的情况。但此算法由于未对寻道进行优化，致使平均寻道时间可能较长。


>  最短寻道时间优先(SSTF):
  　　该算法选择这样的进程，其要求访问的磁道与当前磁头所在的磁道距离最近，以使每次的寻道时间最短，但这种调度算法却不能保证平均寻道时间最短。

> 扫描算法(SCAN):
　　SCAN算法不仅考虑到欲访问的磁道与当前磁道的距离，更优先考虑的是磁头的当前移动方向。例如，当磁头正在自里向外移动时，SCAN算法所选择的下一个访问对象应是其欲访问的磁道既在当前磁道之外，又是距离最近的。这样自里向外地访问，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。这时，同样也是每次选择这样的进程来调度，即其要访问的磁道，在当前磁道之内，从而避免了饥饿现象的出现。由于这种算法中磁头移动的规律颇似电梯的运行，故又称为电梯调度算法。


> 循环扫描算法（CSCAN）
　　CSCAN算法是对扫描算法的改进。如果对磁道的访问请求是均匀分布的，当磁头到达磁盘的一端，并反向运动时落在磁头之后的访问请求相对较少。这是由于这些磁道刚被处理，而磁盘另一端的请求密度相当高，且这些访问请求等待的时间较长，为了解决这种情况，循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头移到最外的被访问磁道时，磁头立即返回到最里的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描

8.对待死锁的策略

> 死锁预防，死锁避免（银行家算法），死锁检测，死锁解除。  

9.线程模型（go的调度模型，java的调度模型，python的调度模型）。   
> 分时调度模型和抢占式调度模型。
> 分时调度模型是指让所有的线程轮流获得 cpu 的使用权,并且平均分配每个线程占
用的 CPU 的时间片这个也比较好理解。  
java 虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用
CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用
CPU。处于运行状态的线程会一直运行，直至它不得不放弃 CPU。

10.单核CPU中的线程会有线程安全问题吗？  
> 需要，单核CPU不能保证调度的顺序性和任务的原子性。单核CPU，一个进程中往往也是有多个线程存在的，每个线程各司其职，CPU来调度各线程。复用。

11.前台进程和后台进程的区别。  


> **区别**  
1,前台进程你可bai以操作,后台进du程你不能操作(除了把它关闭).  
2,前台进程不全是由zhi计dao算机自动控制,后台进程全都是由计算机自动控制.  
**特征**  
1,前台进程可以以窗口,对话匡的形式在系统中显示.后台进程不行.  
2,在任务栏中点亮的进程都可以称为前台进程.没点亮的为后台进程.  
3,前台进程和后台进程有时候可以互相转换.  


12.五种 I / 0 模型. epoll 、poll和selcet的区别。  


> **五种I/O模型**  
> 1、阻塞I/O（read/write）  
2、非阻塞I/O（如recvfrom，进程会反复调用recvfron）  
3、I/O复用（select/poll）  
4、信号驱动I/O（发送信号调用信号处理函数）  
5、异步I/O  

poll、select -> O(n)
epoll -> O(1)

13.linux的共享内存如何实现。  
> Linux的2.2.x内核支持多种共享内存方式，如mmap()系统调用，Posix共享内存，以及系统V共享内存  

14.fork命令是什么作用，开启一个shell界面对应什么操作。  
> 产生新的进程

# 网络
1.Http的状态码的含义（常见的502，503，500，404，302，303，204，200），以及遇到对应错误问题知道如何处理。


> https://www.cnblogs.com/maigy/p/11480011.html

2.Http的请求构成，和相应的构成。

> 1）请求方法URI协议/版本   
2）请求头(Request Header)   
3）请求正文  
link: https://www.cnblogs.com/dashu123/p/11564006.html

3.Http1.0与1.1区别

> HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理  
HTTP 1.1增加host字段  
100(Continue) Status(节约带宽)  
HTTP/1.1在1.0的基础上加入了一些cache的新特性，当缓存对象的Age超过Expire时变为stale对象，cache不需要直接抛弃stale对象，而是与源服务器进行重新激活（revalidation）  
https://www.cnblogs.com/gofighting/p/5421890.html

4.Http2.0的特性。  
https://blog.csdn.net/zhuyiquan/article/details/69257126  

5.Https的原理。

7.tcp和udp的区别（tcp为什么可以保证传输的可靠性），分别什么常见会应用到。

8.tcp的三次握手和四次挥手（为什么需要三次握手，又为什么需要四次挥手）。

9.tcp连接中的状态，time_wait状态码过多，如何解决，close_wait过多该如何解决。
> 通信双方建立TCP连接后，主动关闭连接的一方就会进入TIME_WAIT状态。
> 如发现系统存在大量TIME_WAIT状态的连接，通过调整内核参数解决：
编辑文件/etc/sysctl.conf，加入以下内容：  
net.ipv4.tcp_syncookies = 1  
net.ipv4.tcp_tw_reuse = 1  
net.ipv4.tcp_tw_recycle = 1  
net.ipv4.tcp_fin_timeout = 30  
然后执行 /sbin/sysctl -p 让参数生效.

10.如何做到免密登陆远程服务器，原理是什么。
SSH无密登录配置
![](https://img-blog.csdnimg.cn/2019111822323777.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTY1MTMzNg==,size_16,color_FFFFFF,t_70)
11.网络的七层通信模型。

12.七层负载均衡和四层负载均衡。 
> https://blog.csdn.net/leader_an_yu_xiao/article/details/88918623 

13.tcp的拥塞控制（慢开始，拥塞避免，快重传，快恢复）和流量控制（滑动窗口机制）的差别。
> https://zhuanlan.zhihu.com/p/37379780
> 
14.ARP协议。
> IP地址与MAC地址的映射关系

15.ping命令的实现原理，ping命令为什么不需要端口号呢?  ICMP协议查看远程服务器的原理。

> ping 命令是基于 ICMP 协议来工作的，「 ICMP 」全称为 Internet 控制报文协议（ Internet Control Message Protocol）。ping 命令会发送一份ICMP回显请求报文给目标主机，并等待目标主机返回ICMP回显应答。因为ICMP协议会要求目标主机在收到消息之后，必须返回ICMP应答消息给源主机，如果源主机在一定时间内收到了目标主机的应答，则表明两台主机之间网络是可达的。  
> 
> 假设有两个主机，主机A（192.168.0.1）和主机B（192.168.0.2），现在我们要监测主机A和主机B之间网络是否可达，那么我们在主机A上输入命令：ping 192.168.0.2  
> 此时，ping命令会在主机A上构建一个 ICMP的请求数据包（数据包里的内容后面再详述），然后 ICMP协议会将这个数据包以及目标IP（192.168.0.2）等信息一同交给IP层协议。  
> IP层协议得到这些信息后，将源地址（即本机IP）、目标地址（即目标IP：192.168.0.2）、再加上一些其它的控制信息，构建成一个IP数据包。  
> IP数据包构建完成后，还不够，还需要加上MAC地址，因此，还需要通过ARP映射表找出目标IP所对应的MAC地址。当拿到了目标主机的MAC地址和本机MAC后，一并交给数据链路层，组装成一个数据帧，依据以太网的介质访问规则，将它们传送出出去。  
> 当主机B收到这个数据帧之后，会首先检查它的目标MAC地址是不是本机，如果是就接收下来处理，接收之后会检查这个数据帧，将数据帧中的IP数据包取出来，交给本机的IP层协议，然后IP层协议检查完之后，再将ICMP数据包取出来交给ICMP协议处理，当这一步也处理完成之后，就会构建一个ICMP应答数据包，回发给主机A  
> 在一定的时间内，如果主机A收到了应答包，则说明它与主机B之间网络可达，如果没有收到，则说明网络不可达。除了监测是否可达以外，还可以利用应答时间和发起时间之间的差值，计算出数据包的延迟耗时。  


> ping用的icmp协议，独立的协议，既不是tcp也不是udp，不使用任何端口。



16.从输入网址到解析出内容发生了什么。

17.DNS协议
> 
DNS协议则是用来将域名转换为IP地址（也可以将IP地址转换为相应的域名地址）。
link: https://blog.csdn.net/baidu_37964071/article/details/80500825

18.VPN的实现原理是什么
> link: https://yuerblog.cc/2017/01/03/how-vpn-works-and-how-to-setup-pptp/

# Linux操作命令
1. 如何查看进程，如何查看线程，如何查看某个进程的线程,top -H [-p pid], ps -T [-p pid]。
2. 如何查看内存使用状况。
3. 如何查看磁盘的使用状况。df -h
4. 查看目录的使用状况。du -sh
5. 查看某个端口的使用状况。lsof -i:8088
6. 实时的查看日志文件。tailf -n 50 [fileName]
7. 查看某个日志文件中的内容。grep -i "xxx" file
8. 不想查看文件中的内容。grep -v "xxx" file，不想查看多个内容 grep -v "xxx \| yyy" file
9. 取文件的前50行。head -n 50 file
10. 查看文件的多少行。wc -l filename
11. 分割一个文件，以1000行为一个文件。spilt -l 1000 filename -d -a 5
12. 将一个文件中的A全部替换成B 。在命令行模式下  输入%s/A/B/g
13. 动态的查看进程状态，watch -nl "ps -ef" 或者 top

# 数据库的知识点
1.说几种知道的索引。
2.mysql中你知道哪些优化方式。

> https://zhuanlan.zhihu.com/p/86871140

3.mysql中innodb索引结构，B+树的特性。为什么使用B+树，不使用B树。
4.mysql的四种隔离级别。mysql的RR级别的隔离会产生幻读吗？如果不会是采用什么方式解决的呢？ innodb的RR隔离级别可以重复读，是采用的什么原理呢(MVCC)？MVCC是什么？


> mysql如何实现避免幻读  
在快照读读情况下，mysql通过mvcc来避免幻读。  
在当前读读情况下，mysql通过next-key来避免幻读。  

> 
mvcc全称是multi version concurrent control（多版本并发控制）。mysql把每个操作都定义成一个事务，每开启一个事务，系统的事务版本号自动递增。每行记录都有两个隐藏列：创建版本号和删除版本号。

5.mysql集群，集群出现延迟如何解决。
> 
https://blog.csdn.net/miyatang/article/details/84397111

6.mysql的存储引擎innodb中的主级索引和二级索引是指什么？

> 每个InnoDB表具有一个特殊的索引称为聚簇索引（也叫聚集索引，聚类索引，簇集索引）。如果表上定义有主键，该主键索引就是聚簇索引。如果未定义主键，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚簇索引。如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。  
表中的聚簇索引（clustered index ）就是一级索引，除此之外，表上的其他非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。
