作者：yizhua
链接：https://www.nowcoder.com/discuss/458641?channel=1009&source_id=home_feed
来源：牛客网

2020.07.12 字节客户端 一面 1h
STL

多态

虚函数

不用指针引用是否能发生动态绑定

声明Base对象用Derive对象赋值，会发生什么

拷贝初始化和直接初始化区别

智能指针 要注意的地方

在构造函数中使用当前类的shared_ptr会出现什么问题

构造函数中调用虚函数会怎么样

对TCP和UDP的理解

为什么3次握手？2次行不行？4次行不行？

滑动窗口

http1.0/http1.1/http2.0区别
> 长连接/只发送header，部分传送（节约带宽）/Host域  
> 多路复用/数据压缩/服务器推送（请求数据时，顺便推送）

http2.0最大的改变
> 多路复用

http2.0多路复用有哪些方式 
> HTTP/2是基于二进制“帧”的协议，HTTP/1.1是基于“文本分割”解析的协议  
> 在多路复用中是基于二进制数据帧的传输、消息、流，所以可以做到乱序的传输。

I／O多路复用 ／同步还是异步
> 同步非阻塞（参考：https://blog.csdn.net/n1314n/article/details/89413187）

I／O复用系统调用是否阻塞
> 多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用select和poll函数，传入多个文件描述符（FileDescription，简称FD），如果有一个文件描述符（FileDescription）就绪，则返回，否则阻塞直到超时。

死锁形成的条件 解除死锁 避免死锁

什么是系统调用及过程

系统调用和普通函数调用的区别

算法题：二叉树节点之间的最大距离

https过程

非对称加密的实现，为什么公钥加密私钥解？

RSA加密算法

2020.07.20 字节客户端 二面 48min
自我介绍

做过的对自己影响最大的项目／功能

实习对自己未来的影响

浏览器输入URL的细节

线程与进程

同步与异步

串行／并行／并发

算法题：圆圈中最后剩下的数字（26’10”~39’50”）

2020.07.24 字节客户端 三面 1h23min
自我介绍

实习中最有挑战的事情，解决问题的过程

字节对齐的原因，规则

堆栈区别

SpringBoot 不会。。

AOP设计方法 面向切面 不会。。

内联函数原理

内联的规则，不能声明为内联函数的情况

递归函数可以内联吗 不会。。

多态和虚函数

基类，派生类虚函数表分布

重写基类虚函数后，怎么调用基类虚函数

https加密流程

连接建立以后仍然用非对称加密有什么问题，除了慢呢 不会。。
> https://blog.csdn.net/weixin_39138071/article/details/85000461

对称加密更快吗，为什么

网络环境不好，采取什么措施来提升http请求成功率（提示：为什么会失败）
> 1）IP直连重试，通过配置直连IP数来控制重试次数  
> 2）超级管道重试，可以配置1~3次重试   
> 3）HTTP重试，可以配置1~3次重试  
> 4）原url重试，可以配置1~3次重试  


> 推荐的请求策略是首次请求走H2，当失败重试时走HTTP/1.1  
> 适当的超时设置是一个重要影响因素
> 接口数据体积越小，请求成功率越高

> 参考：https://www.cnblogs.com/imstudy/p/12744273.html

应用层有什么办法减少网络拥塞，发的包如何优化
> 压缩？

DNS查询过程中有没有可能失败，一定会成功吗
> DNS-Rcode 参考：https://zhuanlan.zhihu.com/p/40659713  
> 域名记录不存在/权威解析失败
> ![](https://pic4.zhimg.com/80/v2-bc5d35e3760818eaf8800e79bea983ee_720w.jpg)

本地DNS缓存没有，不向本地域名服务器请求，有没有其他办法
> HTTPDNS其实就是，不走传统的DNS解析，而是自己搭建基于HTTP协议的DNS服务器集群，分布在多个地点和多个运营商。当客户端需要DNS解析的时候，直接通过HTTP协议进行请求这个服务器集群，得到就近的地址。
> 参考：https://blog.csdn.net/mubowen666/article/details/102503628

线程同步机制

自旋锁和互斥锁的区别，使用场景
> 互斥锁：线程会从sleep（加锁）——>running（解锁），过程中有上下文的切换，cpu的抢占，信号的发送等开销；  
> 自旋锁：线程一直是running(加锁——>解锁)，死循环检测锁的标志位，机制不复杂，主要用于SMP和内核可抢占下，因为在内核不可抢占下，cpu在执行空操作。  
> 互斥锁的起始原始开销要高于自旋锁，但是基本是一劳永逸，临界区持锁时间的大小并不会对互斥锁的开销造成影响，而自旋锁是死循环检测，加锁全程消耗cpu，起始开销虽然低于互斥锁，但是随着持锁时间，加锁的开销是线性增长  
> 自旋锁适用于锁使用者保持锁时间比较短的情况下，若持锁时间太长，性能降低

递归锁有了解吗，递归锁如何如何应对在递归中重复请求锁 不会。。

普通互斥锁递归请求锁会死锁吗
> 会？
> 参考 https://www.cnblogs.com/Jonish/p/3235206.html

虚拟内存

app启动时有很多线程同时启动来请求资源，如何限制最大并发数
> 线程池？Semaphore？

如何优化数据库增删改查速度，除了索引，缓存 不会。。
> 优化语句,升级硬件,如果数据量比较大的话可以考虑分区表 

设计模式了解吗 不会。。

算法题：乱序数组求第k大的元素（小根堆／大根堆／快排分区，时间复杂度最优）
> 容量为k的优先队列